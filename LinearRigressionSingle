import numpy
import pandas
import matplotlib.pyplot as plt


def main():
    x1 = list()
    prices = list()
    x1_test = list()
    prices_test = list()
    dataset = pandas.read_csv("house_data.csv")
    needed_dataset_size = int(len(dataset) * 0.8)
    mean_of_x1 = dataset['sqft_living15'][:needed_dataset_size].mean()
    my_range = dataset['sqft_living15'][:needed_dataset_size].max() - dataset['sqft_living15'][
                                                                      :needed_dataset_size].min()
    mean_of_x1_test = dataset['sqft_living15'][needed_dataset_size:].mean()
    my_range_test = dataset['sqft_living15'][needed_dataset_size:].max() - dataset['sqft_living15'][
                                                                           needed_dataset_size:].min()
    for i in range(0, needed_dataset_size):
        x1.append(scale_feature(dataset['sqft_living15'][i], mean_of_x1, my_range))
        prices.append(dataset['price'][i])

    for i in range(needed_dataset_size, len(dataset)):
        x1_test.append(scale_feature(dataset['sqft_living15'][i], mean_of_x1_test, my_range_test))
        prices_test.append(dataset['price'][i])

    parameters = start_liner_regression(prices, x1)

    # test(prices_test, x1_test, parameters)

    plt.scatter(x1_test, prices_test)
    plt.plot(x1_test, calculate_y_pre(parameters[0], parameters[1], x1_test))
    plt.show()


def scale_feature(x1, mean, my_range):
    return (x1 - mean) / my_range


def start_liner_regression(prices, x1):
    c1 = 0
    c2 = 1
    return gradient_descent(c1, c2, prices, x1)


def gradient_descent(c1, c2, prices, x1):
    learning_rate = 1
    stop_diff = 1
    y_pre = calculate_y_pre(c1, c2, x1)
    old_cost = cost_function(prices, y_pre)
    while True:
        temp_c1 = c1 - learning_rate * diff_cost_function_c1(prices, y_pre)
        temp_c2 = c2 - learning_rate * diff_cost_function_c2(prices, y_pre, x1)
        c1 = temp_c1
        c2 = temp_c2
        y_pre = calculate_y_pre(c1, c2, x1)
        print(old_cost)
        new_cost = cost_function(prices, y_pre)
        if old_cost - new_cost <= 1:
            break
        old_cost = new_cost
    return [c1, c2]


def cost_function(y, y_pre):
    sum = 0.0
    for i in range(0, len(y)):
        sum = sum + numpy.power((y_pre[i] - y[i]), 2)
    return sum / (2 * len(y))


def hypothesis(c1, c2, x1):
    return c1 + c2 * x1


def calculate_y_pre(c1, c2, x1):
    y_pre = list()
    for i in x1:
        y_pre.append(hypothesis(c1, c2, i))
    return y_pre


def diff_cost_function_c1(y, y_pre):
    sum = 0.0
    for i in range(0, len(y)):
        sum = sum + (y_pre[i] - y[i])
    return sum / len(y)


def diff_cost_function_c2(y, y_pre, x1):
    sum = 0.0
    for i in range(0, len(y)):
        sum = sum + ((y_pre[i] - y[i]) * x1[i])
    return sum / len(y)


def test(prices, x1, parameters):
    y_pre = calculate_y_pre(parameters[0], parameters[1], x1)
    print(cost_function(prices, y_pre))


main()
